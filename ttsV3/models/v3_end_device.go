// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V3EndDevice Defines an End Device registration and its state on the network.
// The persistence of the EndDevice is divided between the Network Server, Application Server and Join Server.
// SDKs are responsible for combining (if desired) the three.
//
// swagger:model v3EndDevice
type V3EndDevice struct {

	// The address of the Application Server where this device is supposed to be registered.
	// Stored in Entity Registry and Join Server.
	// The typical format of the address is "host:port". If the port is omitted,
	// the normal port inference (with DNS lookup, otherwise defaults) is used.
	// The connection shall be established with transport layer security (TLS).
	// Custom certificate authorities may be configured out-of-band.
	ApplicationServerAddress string `json:"application_server_address,omitempty"`

	// The AS-ID of the Application Server to use.
	// Stored in Join Server.
	ApplicationServerID string `json:"application_server_id,omitempty"`

	// The KEK label of the Application Server to use for wrapping the application session key.
	// Stored in Join Server.
	ApplicationServerKekLabel string `json:"application_server_kek_label,omitempty"`

	// Attributes of the device. Stored in Entity Registry.
	Attributes map[string]string `json:"attributes,omitempty"`

	// Latest-known battery percentage of the device.
	// Received via the DevStatus MAC command at last_dev_status_received_at or earlier.
	// Stored in Network Server.
	BatteryPercentage float32 `json:"battery_percentage,omitempty"`

	// Authentication code to claim ownership of the end device. Stored in Join Server.
	ClaimAuthenticationCode *V3EndDeviceAuthenticationCode `json:"claim_authentication_code,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// Description of the device. Stored in Entity Registry.
	Description string `json:"description,omitempty"`

	// Demodulation signal-to-noise ratio (dB).
	// Received via the DevStatus MAC command at last_dev_status_received_at.
	// Stored in Network Server.
	DownlinkMargin int32 `json:"downlink_margin,omitempty"`

	// The payload formatters for this end device. Stored in Application Server.
	// Copied on creation from template identified by version_ids.
	Formatters *V3MessagePayloadFormatters `json:"formatters,omitempty"`

	// ID of the frequency plan used by this device.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	FrequencyPlanID string `json:"frequency_plan_id,omitempty"`

	// ids
	Ids *V3EndDeviceIdentifiers `json:"ids,omitempty"`

	// The address of the Join Server where this device is supposed to be registered.
	// Stored in Entity Registry.
	// The typical format of the address is "host:port". If the port is omitted,
	// the normal port inference (with DNS lookup, otherwise defaults) is used.
	// The connection shall be established with transport layer security (TLS).
	// Custom certificate authorities may be configured out-of-band.
	JoinServerAddress string `json:"join_server_address,omitempty"`

	// Last DevNonce used.
	// This field is only used for devices using LoRaWAN version 1.1 and later.
	// Stored in Join Server.
	LastDevNonce int64 `json:"last_dev_nonce,omitempty"`

	// Time when last DevStatus MAC command was received.
	// Stored in Network Server.
	// Format: date-time
	LastDevStatusReceivedAt strfmt.DateTime `json:"last_dev_status_received_at,omitempty"`

	// Last JoinNonce/AppNonce(for devices using LoRaWAN versions preceding 1.1) used.
	// Stored in Join Server.
	LastJoinNonce int64 `json:"last_join_nonce,omitempty"`

	// Last Rejoin counter value used (type 0/2).
	// Stored in Join Server.
	LastRjCount0 int64 `json:"last_rj_count_0,omitempty"`

	// Last Rejoin counter value used (type 1).
	// Stored in Join Server.
	LastRjCount1 int64 `json:"last_rj_count_1,omitempty"`

	// Location of the device. Stored in Entity Registry.
	Locations map[string]Lorawanv3Location `json:"locations,omitempty"`

	// LoRaWAN PHY version. Stored in Network Server.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	LorawanPhyVersion V3PHYVersion `json:"lorawan_phy_version,omitempty"`

	// LoRaWAN MAC version. Stored in Network Server.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	LorawanVersion V3MACVersion `json:"lorawan_version,omitempty"`

	// Settings for how the Network Server handles MAC layer for this device. Stored in Network Server.
	MacSettings *V3MACSettings `json:"mac_settings,omitempty"`

	// MAC state of the device. Stored in Network Server.
	MacState *V3MACState `json:"mac_state,omitempty"`

	// Maximum frequency the device is capable of using (Hz). Stored in Network Server.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	MaxFrequency string `json:"max_frequency,omitempty"`

	// Minimum frequency the device is capable of using (Hz). Stored in Network Server.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	MinFrequency string `json:"min_frequency,omitempty"`

	// Indicates whether this device represents a multicast group.
	Multicast bool `json:"multicast,omitempty"`

	// Friendly name of the device. Stored in Entity Registry.
	Name string `json:"name,omitempty"`

	// Home NetID. Stored in Join Server.
	// Format: byte
	NetID strfmt.Base64 `json:"net_id,omitempty"`

	// The address of the Network Server where this device is supposed to be registered.
	// Stored in Entity Registry and Join Server.
	// The typical format of the address is "host:port". If the port is omitted,
	// the normal port inference (with DNS lookup, otherwise defaults) is used.
	// The connection shall be established with transport layer security (TLS).
	// Custom certificate authorities may be configured out-of-band.
	NetworkServerAddress string `json:"network_server_address,omitempty"`

	// The KEK label of the Network Server to use for wrapping network session keys.
	// Stored in Join Server.
	NetworkServerKekLabel string `json:"network_server_kek_label,omitempty"`

	// Pending MAC state of the device. Stored in Network Server.
	PendingMacState *V3MACState `json:"pending_mac_state,omitempty"`

	// Pending session. Stored in Network Server and Application Server until RekeyInd is received.
	PendingSession *V3Session `json:"pending_session,omitempty"`

	// Stored in Entity Registry.
	Picture *V3Picture `json:"picture,omitempty"`

	// The power state of the device; whether it is battery-powered or connected to an external power source.
	// Received via the DevStatus MAC command at status_received_at.
	// Stored in Network Server.
	PowerState V3PowerState `json:"power_state,omitempty"`

	// ID of the provisioner. Stored in Join Server.
	ProvisionerID string `json:"provisioner_id,omitempty"`

	// Vendor-specific provisioning data. Stored in Join Server.
	ProvisioningData interface{} `json:"provisioning_data,omitempty"`

	// Queued Application downlink messages. Stored in Application Server,
	// which sets them on the Network Server.
	// This field is deprecated and is always set equal to session.queued_application_downlinks.
	QueuedApplicationDownlinks []*V3ApplicationDownlink `json:"queued_application_downlinks"`

	// Recent uplink messages with ADR bit set to 1 sorted by time. Stored in Network Server.
	// The field is reset each time an uplink message carrying MACPayload is received with ADR bit set to 0.
	// The number of messages stored is in the range [0,20];
	RecentAdrUplinks []*V3UplinkMessage `json:"recent_adr_uplinks"`

	// Recent downlink messages sorted by time. Stored in Network Server.
	// The number of messages stored may depend on configuration.
	RecentDownlinks []*V3DownlinkMessage `json:"recent_downlinks"`

	// Recent uplink messages sorted by time. Stored in Network Server.
	// The number of messages stored may depend on configuration.
	RecentUplinks []*V3UplinkMessage `json:"recent_uplinks"`

	// Whether the device resets the join and dev nonces (not LoRaWAN compliant). Stored in Join Server.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	ResetsJoinNonces bool `json:"resets_join_nonces,omitempty"`

	// Device root keys. Stored in Join Server.
	RootKeys *V3RootKeys `json:"root_keys,omitempty"`

	// Default service profile. Stored in Entity Registry.
	ServiceProfileID string `json:"service_profile_id,omitempty"`

	// Current session of the device. Stored in Network Server and Application Server.
	Session *V3Session `json:"session,omitempty"`

	// Skip decryption of uplink payloads and encryption of downlink payloads.
	SkipPayloadCrypto bool `json:"skip_payload_crypto,omitempty"`

	// Whether the device supports class B.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	SupportsClassb bool `json:"supports_class_b,omitempty"`

	// Whether the device supports class C.
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	SupportsClassc bool `json:"supports_class_c,omitempty"`

	// The device supports join (it's OTAA).
	// Copied on creation from template identified by version_ids, if any or from the home Network Server device profile, if any.
	SupportsJoin bool `json:"supports_join,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`

	// Used DevNonces sorted in ascending order.
	// This field is only used for devices using LoRaWAN versions preceding 1.1.
	// Stored in Join Server.
	UsedDevNonces []int64 `json:"used_dev_nonces"`

	// Version Identifiers. Stored in Entity Registry, Network Server and Application Server.
	VersionIds *V3EndDeviceVersionIdentifiers `json:"version_ids,omitempty"`
}

// Validate validates this v3 end device
func (m *V3EndDevice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClaimAuthenticationCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFormatters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastDevStatusReceivedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLorawanPhyVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLorawanVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMacSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMacState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePendingMacState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePendingSession(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePicture(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePowerState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueuedApplicationDownlinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecentAdrUplinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecentDownlinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecentUplinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRootKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSession(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersionIds(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V3EndDevice) validateClaimAuthenticationCode(formats strfmt.Registry) error {

	if swag.IsZero(m.ClaimAuthenticationCode) { // not required
		return nil
	}

	if m.ClaimAuthenticationCode != nil {
		if err := m.ClaimAuthenticationCode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("claim_authentication_code")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V3EndDevice) validateFormatters(formats strfmt.Registry) error {

	if swag.IsZero(m.Formatters) { // not required
		return nil
	}

	if m.Formatters != nil {
		if err := m.Formatters.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("formatters")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateIds(formats strfmt.Registry) error {

	if swag.IsZero(m.Ids) { // not required
		return nil
	}

	if m.Ids != nil {
		if err := m.Ids.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ids")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateLastDevStatusReceivedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.LastDevStatusReceivedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("last_dev_status_received_at", "body", "date-time", m.LastDevStatusReceivedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V3EndDevice) validateLocations(formats strfmt.Registry) error {

	if swag.IsZero(m.Locations) { // not required
		return nil
	}

	for k := range m.Locations {

		if err := validate.Required("locations"+"."+k, "body", m.Locations[k]); err != nil {
			return err
		}
		if val, ok := m.Locations[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *V3EndDevice) validateLorawanPhyVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.LorawanPhyVersion) { // not required
		return nil
	}

	if err := m.LorawanPhyVersion.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("lorawan_phy_version")
		}
		return err
	}

	return nil
}

func (m *V3EndDevice) validateLorawanVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.LorawanVersion) { // not required
		return nil
	}

	if err := m.LorawanVersion.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("lorawan_version")
		}
		return err
	}

	return nil
}

func (m *V3EndDevice) validateMacSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.MacSettings) { // not required
		return nil
	}

	if m.MacSettings != nil {
		if err := m.MacSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_settings")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateMacState(formats strfmt.Registry) error {

	if swag.IsZero(m.MacState) { // not required
		return nil
	}

	if m.MacState != nil {
		if err := m.MacState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mac_state")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validatePendingMacState(formats strfmt.Registry) error {

	if swag.IsZero(m.PendingMacState) { // not required
		return nil
	}

	if m.PendingMacState != nil {
		if err := m.PendingMacState.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pending_mac_state")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validatePendingSession(formats strfmt.Registry) error {

	if swag.IsZero(m.PendingSession) { // not required
		return nil
	}

	if m.PendingSession != nil {
		if err := m.PendingSession.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pending_session")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validatePicture(formats strfmt.Registry) error {

	if swag.IsZero(m.Picture) { // not required
		return nil
	}

	if m.Picture != nil {
		if err := m.Picture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("picture")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validatePowerState(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerState) { // not required
		return nil
	}

	if err := m.PowerState.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("power_state")
		}
		return err
	}

	return nil
}

func (m *V3EndDevice) validateQueuedApplicationDownlinks(formats strfmt.Registry) error {

	if swag.IsZero(m.QueuedApplicationDownlinks) { // not required
		return nil
	}

	for i := 0; i < len(m.QueuedApplicationDownlinks); i++ {
		if swag.IsZero(m.QueuedApplicationDownlinks[i]) { // not required
			continue
		}

		if m.QueuedApplicationDownlinks[i] != nil {
			if err := m.QueuedApplicationDownlinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("queued_application_downlinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V3EndDevice) validateRecentAdrUplinks(formats strfmt.Registry) error {

	if swag.IsZero(m.RecentAdrUplinks) { // not required
		return nil
	}

	for i := 0; i < len(m.RecentAdrUplinks); i++ {
		if swag.IsZero(m.RecentAdrUplinks[i]) { // not required
			continue
		}

		if m.RecentAdrUplinks[i] != nil {
			if err := m.RecentAdrUplinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recent_adr_uplinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V3EndDevice) validateRecentDownlinks(formats strfmt.Registry) error {

	if swag.IsZero(m.RecentDownlinks) { // not required
		return nil
	}

	for i := 0; i < len(m.RecentDownlinks); i++ {
		if swag.IsZero(m.RecentDownlinks[i]) { // not required
			continue
		}

		if m.RecentDownlinks[i] != nil {
			if err := m.RecentDownlinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recent_downlinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V3EndDevice) validateRecentUplinks(formats strfmt.Registry) error {

	if swag.IsZero(m.RecentUplinks) { // not required
		return nil
	}

	for i := 0; i < len(m.RecentUplinks); i++ {
		if swag.IsZero(m.RecentUplinks[i]) { // not required
			continue
		}

		if m.RecentUplinks[i] != nil {
			if err := m.RecentUplinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("recent_uplinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V3EndDevice) validateRootKeys(formats strfmt.Registry) error {

	if swag.IsZero(m.RootKeys) { // not required
		return nil
	}

	if m.RootKeys != nil {
		if err := m.RootKeys.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("root_keys")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateSession(formats strfmt.Registry) error {

	if swag.IsZero(m.Session) { // not required
		return nil
	}

	if m.Session != nil {
		if err := m.Session.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("session")
			}
			return err
		}
	}

	return nil
}

func (m *V3EndDevice) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *V3EndDevice) validateVersionIds(formats strfmt.Registry) error {

	if swag.IsZero(m.VersionIds) { // not required
		return nil
	}

	if m.VersionIds != nil {
		if err := m.VersionIds.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("version_ids")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V3EndDevice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V3EndDevice) UnmarshalBinary(b []byte) error {
	var res V3EndDevice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
